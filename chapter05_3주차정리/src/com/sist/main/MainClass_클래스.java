package com.sist.main;
/*
 *        1. 객체지향 프로그램
 *        ---------------
 *        의 기반은 클래스
 *       ①클래스의 목적은? 1) 재사용이 가능하도록 
 *                       = 상속 => 기존의 클래스를 변경해서 사용할 목적
 *                             : class GenieMusic
 *                               =>class Melon extends GenieMusic
 *                                       -------------기존의클래스를확장
 *                       = 포함 => 기존의 클래스를 그대로 사용
 *                             : class Melon
 *                               {
 *                                  GenieMusic gm=new GenieMusic();
 *                               }
 *                    2) 필요한 데이터를 보호 : 데이터 보호 (캡슐화)
 *                       => 접근지정어 : private => 클래스에서 사용하는 멤버변수는 
 *                                    은닉화 => 메소드에서 기능을 제작
 *                                            ----------------
 *                                            읽기(getter),쓰기(setter)
 *                                            
 *                    3) 수정이 가능 / 추가 가정 => 다형성
 *                       -------    ------
 *                       오버라이딩     오버로딩
 *                    ---------------------------------------------------
 *                    목적 => 유지보수가 쉽게... => 가독성이 높아야함(리팩토링)
 *                           개발(1년) vs 유지보수(10-15년) ==> SI/SM 동시진행필요
 *        
 *       ②클래스를 만드는 과정
 *        1) 클래스 구성요소
 *           class MainClass
 *           {
 *              ---------1.변수선언위치---------
 *               [인스턴스변수] => 여러개를 따로 저장(=new)해서 사용이 가능
 *               혹은
 *               [공유변수/클래스변수:static] => 컴파일러에 의해 자동으로 메모리 (1개만)생성
 *                                      => 데이터 목록에서 주로 쓰임
 *               
 *               예) 
 *                  => 데이터 유형별 자동초기화 결과값
 *                  String name; => class인경우 null
 *                  int age; => class인경우 0
 *                  String address; => class인경우 null
 *                  String phone; => class인경우 null
 *                  double ki; => class인경우 0.0
 *                  char c; => class인경우 '\0'
 *                  boolean b; => class인경우 false (=한번을 메모리에 저장→필요한값으로 변경)
 *                                                                 -----------
 *                                                                  =초기화블록/생성자
 *               권장사항)
 *                 String name,address,phone...등 한줄에 적지 않도록 권장 => 유지보수를위해
 *               
 *               중요사항)
 *                 데이터(변수)는 반드시 외부에서 "접근,변경,손실"을 막기위해 "은닉화=private"를 해야한다
 *                 따라서 모든 변수는 private를 사용한다!!!!
 *                 
 *              ------2.생성자/초기화블록위치------
 *               [생성자] => 접근이 가능 (=public)
 *                      => 무조건 생성하는것이 아님
 *                      => "클래스에는 반드시 생성자가 있어야함"
 *                         만약에 생성자가 없으면 컴파일러가 자동 생성
 *                                         =매개변수가 없는 생성자(디폴트생성자)
 *               예)
 *                class A
 *                {
 *                   =>자동생성 => A(){}
 *                }
 *                class A
 *                {
 *                   A(int a){} =>생성자가 존재 => 자동추가가 안된다
 *                }
 *                
 *               컴파일러가 자동생성)
 *                1] import : import java.lang.*;
 *                            -------------------
 *                              | String , System , Math
 *                2] void method()
 *                   {
 *                      return; => 생략하는 경우 => 자동으로 추가
 *                   }
 *                3] 자바의 모든 클래스는 "Object클래스 상속"
 *                   class A extends Object => Object에서 지원하는 모든 메소드 사용 가능
 *                4] 생성자가 없는 경우 => 자동으로 디폴트 생성자 추가
 *                5] 자바의 모든 클래스는 예외처리를 가지고 있음
 *                                  -----
 *                                  ⓐ컴파일시:javac
 *                                  ⓑ런타임시:java
 *               생성자의 역할)
 *                 = 멤버변수에 대한 초기화 담당
 *                 = 메모리에 저장시 반드시 호출되는 메소드
 *                   => 생성자 호출시 "new 생성자()" 이렇게 안하면 오류남
 *                 = 모든 클래스는 1개이상 존재(없는 경우엔 자동추가)
 *               생성자의 특징)
 *                 = 클래스명과 생성자명이 동일
 *                 = 리턴형이 없음 (****void도 리턴형임!!! 일반함수임!!!)
 *                   class A에서 int A(),void A() => 일반함수 
 *                             A() => 이것만 생성자
 *                 = 생성자는 다른 클래스에서 메모리 할당 후에 사용
 *                   기본 public
 *                 = 필요시 여러개의 생성자를 제작할 수 있다
 *                   같은이름으로 여러개 만들어서 다른 기능 수행
 *                   -------------------=오버로딩~~
 *                                       조건1) 메소드명이 동일하다
 *                                       조건2) 매개변수의 갯수나 데이터형이 다르다
 *                                       조건3) 리턴형은 상관없다
 *                                         예)  int aaa() ==> aaa()  
 *                                             void aaa(int a) ==> aaa(int)
 *                                             void aaa(int b) ==> aaa(int)
 *                                       조건4) 같은 클래스에서 제작
 *                                       조건5) 생성자, 멤버메소드에서도 적용가능
 *                                         예) println() , println(String s)...
 *                                            substring(int s) substring(int s,int e)...
 *               생성자의 사용처)
 *                 = 인스턴스 변수가 명시적인 초기화가 안되는 경우
 *                              ----------ex.파일읽기,DB데이터,크롤링
 *                 = 시작과 동시에 처리해야 하는 명령문
 *                   예) 브라우저켜면 자동로그인, 아이디등록, 윈도우 화면 디자인, 
 *                      서버실행동시에 서버동작, 클라이언트와 DB연결...
 *                      *A a=new A(); 이렇게 안하고
 *                       A a 만 한후
 *                         a.메소드명(); 이렇게 불러오면 에러남
 *                      
 *               [초기화블록] => 생성자 없이 멤버 변수 초기화
 *                         => 컴파일러에 의해 자동호출
 *                         
 *               ⒜ 인스턴스 블록 => 생성자를 주로 사용
 *                  class A
 *                  {
 *                     //1번실행
 *                     int a; 
 *                     //2번실행
 *                     {
 *                        a=(int)(Math.random()*100+1);
 *                     }
 *                     //이렇게 실행하는것보단
 *                     
 *                     //1번실행
 *                     A()
 *                     {
 *                        a=(int)(Math.random()*100+1);
 *                     }//이렇게 한번에 실행하는것이 더 효율적
 *                  }
 *                  
 *               ⒝ static 블록 => 자동으로 메모리 할당 => 생성자 사용하지 않아도됨
 *                 class A
 *                  {
 *                     static int a; //생성자 호출없이도 사용가능
 *                     static
 *                     {
 *                        a=100;
 *                     }
 *                  }
 *                  A aa=new A(); => aa.a
 *                  A.a 이렇게 가능
 *                  
 *                주의점)
 *                 인스턴스블록 / static블록
 *                 class A
 *                 {
 *                    int a;
 *                    static int b; //일때
 *                    {------인스턴스블록부분-----(오류없음)
 *                       a=100;
 *                       b=200;
 *                    }----------------------
 *                    static
 *                    {------static블록부분-----(오류발생)
 *                       a=1000; //여기서 오류남!!!
 *                               //=>static에선 인스턴스 사용불가능
 *                               //객체생성후 사용가능
 *                       b=1000; //static에서 static변수는 사용가능
 *                    }-----------------------
 *                 }
 *                 
 *                초기값에 대한 호출 순위)
 *                 1. 명시적 초기화
 *                    int a=10; //불가능시 2.3번으로 넘어감
 *                 2. 초기화 블록
 *                    a=100;
 *                 3. 생성자
 *                    a=200;
 *                    
 *                변수)
 *                 멤버변수 / static변수 / 지역변수 => 모두 반드시 초기화를 해서 사용해야함
 *                 
 *              ----------3.메소드위치----------
 *               [메소드] => 다른 클래스와 통신 (=public)
 *                = 리턴형
 *                  => 사용자 요청에 대한 처리 결과값(1개만 사용이 가능)
 *                  => 기본형
 *                     정수 => int, long
 *                     실수 => double
 *                     문자 => char
 *                     논리 => boolean
 *                  => 참조형
 *                     배열 => int[]
 *                     클래스 => A
 *                  => 리턴형 : 리턴값과 데이터형 일치권장
 *                          : 결과값이 없는 경우 void사용
 *                            void는 return생략가능
 *                          : 리턴형이 있는경우
 *                            반드시 결과값을 받아서 저장해야함
 *                            int aaa() => int a=aaa()
 *                          : 메소드 호출시 메소드의 return값 수행후
 *                            호출된 위치로 돌아옴
 *                = 메소드명
 *                  *변수명칭법과 동일함
 *                  *길이제한은 없지만 가급적이면 압축 : 5~12
 *                  *자바 개발자의 약속사항 : 소문자로 시작
 *                                   : 소프트웨어 이행문제로 가급적 영문사용
 *                   //리눅스의 차세대 운영체제=우분투(AWS)
 *                   //개발에선 윈도우/맥을 주로사용...호스팅을 리눅스에함
 *                   //프로젝트는 GIT(원격) => 윈도우와 맥이 다르면 경로문제가 생김..
 *                   
 *                = 매개변수
 *                  사용자가 요청 값 => 로그인(id,pwd,check)
 *                  => 사용자의 입력, 마우스 클릭, 키보드 이용 => 매개변수로 처리
 *                  => 매개변수의 갯수는 제한이 없다 => 그러나 가급적 작게 사용한다
 *                                             -------------------
 *                                             3개이상일시 배열/클래스로 모아서 전송
 *                  => 메모리 할당 시기가 메소드 호출시마다 할당됨
 *                  => 매개변수는 지역변수의 일종 => 메소드가 종료되면 자동으로 사라진다
 *                     => 자동해재 (메모리에서 자동처리)
 *                     => 초기값을 주는 경우
 *                        메소드에서 초기화를 해준다
 *                     예) public void disp(int a)
 *                        {
 *                        }
 *                        disp(10) => 매개변수의 값을 설정한다
 *                        -------호출
 *                  
 *                형식) 
 *                    ① 멤버메소드
 *                      public 리턴형 메소드명(매개변수목록) <선언부>
 *                      {
 *                         <구현부>
 *                         => 인스턴스 메소드나 인스턴스 변수 사용 가능
 *                         => static 메소드나 static 변수 사용 가능
 *                      }
 *                      <호출법>
 *                      객체명.메소드() ex.scan.next();
 *                      
 *                     
 *                    ② static메소드
 *                      public static 리턴형 메소드명(매개변수목록) <선언부>
 *                      {
 *                         <구현부>
 *                         => static 메소드나 static 변수 "만" 사용이 가능
 *                         => 인스턴스 메소드나 인스턴스 변수 사용 "불가능"
 *                            만약에 사용한다면 "반드시" 객체생성후 사용가능
 *                      }
 *                      <호출법> 
 *                      클래스명.메소드() ex.Math.random()
 *                      
 *                    예) String s="";
 *                       -----멤버메소드-----
 *                       s.substring()
 *                       s.trim()
 *                       s.replace()
 *                       ----static메소드----
 *                       String.valueOf()
 *                    
 *                    예) Calender c= Calender.getInstance() 
 *                       ---------     =>이부분에 new가 없으면 추상클래스(인터페이스)
 *                       =추상클래스
 *              ----------------------------
 *           }

 *           ***코드영역
 *           class
 *           {
 *               선언만 가능 : 변수선언 메소드선언
 *               구현은 불가능 : 메소드 호출, 연산자 처리, 제어문 사용
 *               *클래스도 데이터 형이다(형변환 => 상속)
 *           }
 *           method
 *           {
 *               선언/구현 둘다가능 : 선언(지역변수), 메소드 호출, 연산처리, 제어문 => 구현
 *               메소드의 흐름 : 사용자요청=>처리=>결과값전송
 *               "CRUD"가 기본 method기능 : 회원가입(쓰기)/회원정보(읽기)/회원(수정)/회원탈퇴(삭제)
 *               *생성자, 초기화블록(구현) 또한 메소드이다 
 *               *사용자 정의로 만든 메소드나 생성자는 반드시 호출을 해야함 => 자동호출이없음
 *           }
 *           
 *        2) 메모리 저장
 *        3) 활용 (호출)     
 *       
 *       ③클래스의 종류
 *        1) 일반 클래스
 *        2) 추상 클래스
 *        3) 인터페이스
 *        4) 내부 클래스
 *           = 멤버클래스 : 클래스안에 클래스를 집어넣음**
 *           = 지역클래스 : 클래스 안에 메소드안에 클래스를 집어넣음 따라서 메소드 호출시 포함된 클래스 생성
 *           = 익명의 클래스 : 클래스 안에 new로 생성후 메소드 추가/변경을 진행 ==> 상속없이 오버라이딩이 가능
 *             
 *        5) 종단 클래스 : 상속을 할수 없는 클래스=마지막클래스
 *           = final class (예) String , Math , System...)
 *        
 *      ④비정상 종료를 방지하는 프로그램 구현 => 예외처리
 *      -------------------------------------------------------------------[교재기준8장 기본문법내용]
 *      
 */
public class MainClass_클래스 {
	int a=100;
	public static void aaa()
	{
		//static에서 인스턴스는 오류남
		//System.out.println(a); //오류남
		
		//static에서 인스턴스는 객체생성 후 사용해야함
		MainClass_클래스 m=new MainClass_클래스();
		System.out.println(m.a);
	}

	public static void main(String[] args) {
		

	}

}
