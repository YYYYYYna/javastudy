/*
 *      => 자바 기본 문법 
 *         ----------
 *         데이터형 (메모리크기)
 *         = 기본형
 *         = 참조형 => 클래스 / 배열
 *         
 *         [클래스]
 *         1) 데이터만 모아서 관리 => 변수
 *            --------------
 *            => 초기화가 필요
 *               ---- ① 명시적초기화
 *                    ② 초기화 블록
 *                    ③ 생성자 =====> 가장많이 사용
 *                    
 *         2) 메소드만 모아서 관리 => 
 *         
 *         [클래스의 구성요소]
 *         class ClassName
 *         {
 *            --------------
 *             데이터 저장 공간 : 멤버변수 => 프로그램 종료시까지 유지
 *                                  => 다른 클래스에서도 사용이 가능
 *             인스턴스 변수 => new를 이용해서 메모리에 저장 / 실행마다 메모리공간 따로 생성
 *                : 데이터명 변수명;
 *             공유변수 => 컴파일러에 의해 자동생성 / 메모리공간 한개만 사용
 *                : static 데이터형 변수명;
 *            --------------
 *             생성자 : 변수에 대한 초기화 
 *                  *** 클래스 영역에서는 선언만 가능
 *                  : 특징
 *                    - 클래스명과 동일
 *                    - 리턴형 없다 (**void는 리턴형이라서 생성자불가능 일반변수취급함!)
 *                    - 여러개 사용 할 수 있다 (=같은이름으로 여러개 사용) 
 *                      => 오버로딩 : 중복함수정의 (*면접에자주나오니주의)
 *                               : new, add라는 단어가 답으로 나와야함
 *                               : 메소드명이 동일하다
 *                               : 매개변수의 갯수나 데이터형이 틀리다
 *                               : 리턴형은 관계가 없다.
 *                         예)
 *                         A() => A()
 *                         A(int a, int b) => A(int ,int)
 *                         A(String s, double d) => => A(String, double)
 *                         A(int c, int d) => A(int ,int)//중복
 *                         => 실제 메소드에서도 적용
 *                  [기타] 
 *                   : 생성자를 사용하지 않고 초기화 하는 방법
 *                   => 인스턴스 블록 : new에서 메모리를 불러와야하기때문에 생성자를 호출해야함
 *                      {
 *                         구현 => 변수의 초기화
 *                      }
 *                      ==>생성자
 *                   예) class A
 *                      {
 *                         A(){
 *                           
 *                         }
 *                      }
 *                      new
 *                      
 *                   => 정적 블록 : static으로 메모리가 자동할당되기때문에 생성자 필요없음
 *                      static
 *                      {
 *                         구현 => static의 초기화
 *                      }
 *                   예) class A
 *                      {
 *                         static int[]
 *                         
 *                         static{
 *                           
 *                         }
 *                      }
 *                      
 *            --------------
 *              멤버메소드
 *               = static 메소드
 *               = static 리턴형 메소드(매개변수 목록)
 *                 {
 *                    
 *                 }
 *               = 인스턴스 메소드 => 따로생성
 *                 리턴형 메소드(매개변수 목록)
 *                 {
 *                 
 *                 }
 *            --------------
 *               예를들어 계산기를 두개 켜놓고 계산기1에 9를 눌렀을데 계산기2도 9가 눌리면 static
 *                     근데 계산기는 독립적으로 실행됨으로 이건 인스턴스 변수라고 볼수 있다.
 *               예를들어 크롬창을 두개 열때 2번째 페이지의 크기가 1번째 페이지와 가로세로크기가 같은부분=static
 *                     그러나 크롬창1에서 naver를 들어가도 크롬창2에선 실행되지 않음=인스턴스
 *               결론적으로 내가 입력하는데 출력값이 동일하다=static / 출력값이 다르다=인스턴스
 *                      한개의 동작으로 여러개의 공유값이 달라진다=static / 한개의 동작이 한개만 달라진다=인스턴스
 *            --------------
 *            --------------
 *         }
 *         
 *   생성자 => 오라클 연동 (데이터가 저장된 장소)
 *           : 영구적으로 데이터를 저장함 회원가입 정보같은걸 올려두고 끌어오는듯
 *           : 원격으로 연동 가능
 *           : 서버 실행과 동시에 데이터를 가져와야 하기 때문에 오라클과 연동해둠
 *           
 *   윈도우 초기화 => 시작과 동시에 레이아웃을 잡고 처리(이때도 생성자가 사용됨)
 *   
 *   따라서 실습을 위해 변수값으로 생성자를 사용하는것임
 *   실무에서는 서버연결/서버구동 에서 주로 사용함
 *           -----------
 *           = ServerSorket()
 *           
 *   
 *       [메소드] 
 *       : 인스턴스 메소드 => new를 이용해 메모리에 저장할때마다 생성
 *         ---------- 객체 생성마다 => 따로작동
 *         호출 => 객체명.메소드()
 *                ----------
 *       형식 
 *       : 리턴형 메소드명(매개변수목록) <선언부>
 *         {
 *             <구현부>
 *         }
 *         리턴형 : 기본형 , 배열 , 클래스
 *              => 요청에 대한 결과값 (1개만 사용이 가능)
 *              => 여러개인 경우 : 클래스/배열
 *              => 리턴형이 없는 경우 : void
 *              => 메소드명은 알파벳이나 한글로 시작한다.
 *                 숫자를 사용할수도 있음(단,앞에사용금지)
 *                 키워드는 사용 할 수 없다.
 *                 ----클래스명,메소드명은 키워드가 아니다
 *                 공백을 주면 안됨
 *                 특수문자 _ $ 만 사용가능
 *                 소문자로 시작 두번째단어는 대문자시작을 권고한다
 *                 ***소프트웨어 이행관련 한글은 문제발생할수 있음 
 *                    가급적 영어사용 권장
 *                    원도우개발 => 서버리눅스사용
 *                  Full Stack   AWS(PaaS)
 *                 =>StringBoot3
 *                 
 *         매개변수 : 사용자가 보내준 값(→여러개가 있을수도 있음/가급적 3개 미만으로)
 *                                                --------------
 *                                                3개 이상일때는 클래스/배열이용
 *         
 *         void 메소드명()
 *         {
 *             return; => 생략가능 => 컴파일러가 자동추가
 *                     => 메소드 종료를 뜻함 : 원하는 위치에 설정 가능
 *         }
 *         ===> 리턴형없이 그냥 호출함
 *         ------------------------------------------------
 *         int 메소드명()
 *         ---
 *         {
 *             return 정수값;
 *                    ---- 두 데이터형이 일치하거나 정수값이 더 작아야함
 *         }
 *         
 *         ------------------------------------------------
 *         int[] 메소드명()
 *         {
 *             int[] arr=new int[10];
 *             return arr;
 *         }
 *         ===> int[] arr=메소드명();
 *         ------------------------------------------------
 *         //클래스명과 메소드명이 동일해도 된다.
 *         class A
 *         A 메소드명()
 *         {
 *            A a=new A();
 *              -
 *            return a;
 *                   -
 *         }
 *         ===> A a=메소드명();
 *         ------------------------------------------------
 *         **메소드는 호출시마다 => 처음부터 return이 있는 곳까지 실행
 *                         => 호출된 위치로 다시 돌아간다.
 *         예)
 *         void aaa()
 *         {
 *            1
 *            2
 *            3
 *            return;
 *          }
 *         void main()
 *         {
 *            4
 *            5
 *            aaa(); //1 2 3 수행
 *            6
 *            7
 *            aaa(); //1 2 3 수행
 *            8
 *            9
 *            return;
 *          }
 *          [실행순서]===> 4 5 (1 2 3) 6 7 (1 2 3) 8 9
 *                 ===> 항상 맨 마지막줄이 아니라 return이 끝나는 줄임!
 *                 ===> 반복제거, 재사용시 많이 쓰임 / 유지보수가 용이 / 소스가 간결
 *                                             ------구조적인프로그램------
 *                 
 *                 객체지향 프로그램 => 메소드
 *                 
 *          프로그램 기획의 단계에서 ① 벤치마킹 ② 요구사항분석 단계는 
 *          ===> ""변수/메소드중 메소드를 먼저 봐야함""
 *          ===> 예를들어 계산기에서는 7과8을 눌렀을때 15가 아닌 78로 
 *               인식되는과정(=메소드)를 보고 반대로 String(=변수)를 파악할 수 있어야함
 *          ===> 숫자야구게임의 경우 
 *                 [각 단계시]     [필요한 변수]
 *               컴퓨터 난수 발생  =>  com[]
 *               사용자 입력     => user[]
 *               비교시행      => com[] user[]
 *               힌트       => user[], s, b
 *               종료       => s
 *               따라서 이 과정(=메소드)를 통해 변수를 파악했을때
 *               [지역변수:중복없는변수] b
 *               [멤버변수:중복된변수] com[], user[], s 가 도출됨
 *          ===> 홈페이지 예약시에도 예약 과정을 봐야 어떤 변수가 필요한지 파악가능          
 *             
 */

//  클래스에 메소드(리턴형없는void형) 넣어서 사용한 방식
import java.util.Arrays;

class User {
	// 5개의 정수 난수발생 => 정렬하는 프로그램 제작 => 출력

	// => 따라서 이 과정에서 배열은 멤버변수(:중복된변수)
	int[] arr = new int[5]; // 멤버변수(:중복된변수)생성

	// 난수발생 초기화 => 생성자 사용
	User() {
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int) (Math.random() * 100 + 1);
		}
		System.out.println("정렬전 : ");
		System.out.println(Arrays.toString(arr));
	}

	// 멤버변수가 있음으로 리턴형을 사용하지 않아도됨
	void sort()// 정렬시작
	{
		for (int i = 0; i < arr.length - 1; i++) {
			for (int j = i + 1; j < arr.length; j++) {
				if (arr[i] > arr[j]) {
					int temp = arr[i];
					arr[i] = arr[j];
					arr[j] = temp;
				}
			}
		}
	}

	void print() {
		System.out.println("정렬후 : ");
		System.out.println(Arrays.toString(arr));
	}
}

public class MainClass {
	public static void main(String[] args) {
		User user = new User();
		user.sort();
		user.print();
	}
}
