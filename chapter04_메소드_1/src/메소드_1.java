/*
 *     데이터 저장 ==========> 데이터 가공(처리) ==========> 가공된 데이터 출력
 *     →데이터 한개 저장        →사용자 요청 처리             →사용자 요청
 *          |                |   (로그인, 검색결과)
 *          |                ↓  
 *          |               1)연산자
 *          |               2)제어문
 *          |                -------묶어서 사용
 *          |                -------명령문의 집합 : 메소드
 *          |                -------기능별처리
 *          ↓                
 *         변수 : (지역변수, 전역변수 => 공유 변수, 객체 변수)
 *               ------  ------ 클래스
 *     →데이터 묶어서 사용 : 같은 데이터형을 묶어서 관리
 *                   => 변수명을 통일(인덱스)=배열
 *                    : 다른 데이터형을 묶어서 관리 (=클래스)
 *                    
 *     메소드(Method) : 클래스의 구성요소
 *                      |
 *                    생성자, 변수, 메소드
 *                          ---  ----
 *     1) 사용 목적 => 1.가독성 2.재사용성 3.속도(최적화)
 *                  ---------------
 *                     |
 *                    메소드
 *                    
 *        = 분석(가독성좋음) => 수정(유지보수) , 오류처리
 *          |=기능별 분리(로그인처리, 회원가입, 목록, 페이징...)
 *        = 다른 클래스와 연결(메세지)
 *          객체지향 프로그램은 여러개의 클래스를 만들어서 연관관계
 *          ex. Scanner...(사용자 정의)
 *              scan.nextInt()
 *                   --------=입력된 정수를 읽는 메소드
 *              System.out.println(); => 화면에 출력하는 메소드
 *              trim(), length() 등등
 *              => "메소드는 1가지 기능만 수행이 가능하게 만든다."
 *                 1) 입력
 *                 2) 요청 처리 => 기능에 따라서 세분화 (여기는 여러개 메소드 제작 가능)
 *                 3) 출력
 *              
 *        = 반복 수행을 제거
 *          오라클 연결
 *          --------
 *          = 목록 출력
 *            오라클 연결==
 *            데이터 처리  => 이렇게 반복되는 부분을 재사용하는것
 *            오라클 닫기==
 *          = 데이터 저장
 *            오라클 연결
 *            데이터 처리
 *            오라클 닫기
 *          = 데이터 수정
 *            오라클 연결
 *            데이터 처리
 *            오라클 닫기
 *          = 데이터 삭제
 *            오라클 연결
 *            데이터 처리
 *            오라클 닫기
 *          = 상세보기
 *            오라클 연결
 *            데이터 처리
 *            오라클 닫기
 *          = 재사용이 높다
 *          = 구조적 프로그램 작성 => 단락을 나눠서 작업
 *     
 *     2) 메소드 형식
 *         [접근지정어]   [옵션]  리턴형 메소드명(매개변수...) : 선언부
 *        public(공개)  static : new를 사용하지 않고 자동으로 메소드에 저장
 *        private     abstract : 선언 => 추상클래스 / 인터페이스(설계) => 요구사항 분석
 *        default      final : 상속불가능(수정이 불가능) ex=Math,String,System...
 *        protected
 *        {
 *            구현부
 *        }
 *        리턴형 : 사용자 요청에 대한 처리 결과값
 *        매개변수 : 사용자의 요청값 ()
 *                예) 로그인 요청에서는 ID,PW가 매개변수
 *                   아이디 찾기에서는 ID가 매개변수
 *                   검색을 할 경우에는 검색어가 매개변수
 *                   홈페이지경우에는 각 페이지의 고유주소가 매개변수
 *                   String substring(int start,int end)
 *                   ------           -----------------
 *                   여기가 리턴형 부분      여기가 매개변수 부분
 *                 => 일반 : 3개이상 묶어서 매개변수로 설정
 *                         ------배열, 클래스
 *       매소드명 : 식별자(변수)
 *               = 알파벳이나 한글로 시작한다
 *               = 메소드명의 길이 제한은 없다
 *                 ------------------- (3~10)
 *               = 숫자를 사용할 수 있다.
 *               = 특수문자 사용 가능 (_ , $)
 *               = 키워드는 사용 할 수 없음
 *               = 공백을 사용하면 안된다.
 *       
 *       ====> 선언부, 구현부의 구별이 중요함
 *             리턴형 메소드명(매개변수...) => 선언부
 *             {
 *                구현부 => 소스코딩 위치
 *             }
 *       ====> 약속사항
 *             ① 소문자로 시작한다.
 *             ② 두개의 단어가 있는 경우 두번째 단어 첫자는 대문자로
 *             ③ 데이터 저장 : set변수명()...
 *             ④ 데이터 읽기 : get변수명()
 *               
 *     3) 메소드 제작시 고민
 *        ------------------------------------------
 *          리턴형 (처리 결과값)       매개변수 (사용자 요청값)
 *        ------------------------------------------
 *                O                     O
 *                => String replace(char c1, char c2)
 *                => 리턴형으로 사용가능한 범위
 *                   : 기본형 (int, long, double, boolean, char)
 *                   : 참조형 (int[], boolean[])
 *                     -----------------------
 *                     리턴형은 한개만 사용할 수 있다.
 *        ------------------------------------------
 *                O                     X
 *                => double Math.random()
 *                => String trim()
 *                => int nextInt()
 *                이렇게 괄호안에 값(매개변수)가 없는 구조
 *        ------------------------------------------
 *                X                     O
 *                메소드 자체에서 처리 후 출력 : 리턴형존재X
 *                => void main(String[] args) 
 *                   : 리턴형이 없는경우는 꼭 void를 붙여야함
 *                => void println(~~)
 *                   : 따라서 void=리턴형이없다는뜻
 *        ------------------------------------------
 *                X                     X
 *                이런형태는 많이 사용 빈도수가 거의 없다.
 *                => System.out.println()
 *                   : 다음줄에 출력
 *        ------------------------------------------
 *        => 이렇게 총 4가지의 유형을 가지고 있지만 
 *           어떤 유형을 사용할 지는 각자 판단을 해서 진행해야함
 *           
 *     4) 메소드 선언 및 호풀 방법
 *        public class A
 *        {
 *         ----------------------
 *              메소드 선언 위치
 *         ----------------------
 *         public static void main(String[] args) {
 *         }
 *         ----------------------
 *              메소드 선언 위치 (메소드안에서 메소드 선언은 불가능)
 *              클래스 안에 선언
 *         ----------------------
 *         자바는 메소드 클래스 종속 => 메소드
 *         클래스 밖에서 선언 => 함수(C/C++) => 독립적 사용이 불가능
 *        }***자바는 항상 클래스 블록 안에 선언해야하는걸 잊지말기
 *        
 *        형식) 
 *           리턴형 메소드명(매개변수...)
 *           ----
 *           {
 *              사용자 요청 처리
 *              return 값;
 *                     -- 리턴형과 값이 일치해야함
 *                        (간혹 리턴형이 실제 전송값보다 클 수 있다.) 
 *           }
 *           int라면? 메소드명(매개변수)
 *           {
 *              return int,char,short,byte 값 가능
 *           }
 *           void 메소드명(매개변수)
 *           ----=전송할 데이터가 없다 => 자체처리
 *           { 
 *              return; (void라서 값 생략함 / return자체도 생략 가능)
 *                                        ------------------
 *           }                            =>컴파일러가 자동으로 추가해주기 때문
 *                                          따라서 존재는 하는 상황임
 *                                          
 *           ==> int 호출하는 경우
 *           int 메소드명(매개변수)
 *           ---→해당 두 부분 데이터형이 일치해야함
 *           {
 *                return 10;
 *           }
 *           => int a=메소드명(값...)
 *              ---→해당 두 부분 데이터형이 일치해야함
 *           => 메소드는 호출시마다 처음부터 시작한다.
 *           => 메소드는 호출 후 해당 메소드의 리턴값까지 실행 후에 호출된 위치로 돌아옴
 *           
 *           static int plus(int a, int b)
 *           {
 *               return a+b;
 *           }
 *           int c=plus(10,20) => c=30
 *                 ---- ----→해당부분에는 변수말고 값을 넣어줘야함
 *                 생성된 메소드?리턴값
 *     5) 메소드 응용
 *                           
 */
public class 메소드_1 {
    static void a()
    {
    	System.out.println("a()메소드 start...");
    	System.out.println("a()메소드 사용자 요청 처리 종료...");
    	System.out.println("a()메소드 end");
    	return;//void라서 생략가능 그러나 존재함 => 값을 보내줄때 한개만 사용이 가능
    }
    //프로그램 시작점 따라서 main은 항상 존재해야함
	public static void main(String[] args) {
		a();//a메소드 호출
		System.out.println("============================");
		a();//a메소드 호출
		System.out.println("============================");
		a();//a메소드 호출
		System.out.println("============================");
		System.out.println("=> 동시에 3번 호출한 결과값을 통해 진행 경로가 어떻게 되는지 확인하기");
		
	}

}
