package com.sist.main;
/*
 *      => 추후에는 실행속도를 높일수 있도록 최적화작업을 해줘야함
 *      => exe => 자바는 웹J2EE과 모바일J2ME에 강함 => J2SE
 *      
 *      *** 자바는 오버라이딩이다 => 기존 내용도 변경할 부분이 많기때문
 *                                     ---을 쉽게하기 위해 프레임워크(실제소스)를 주로 사용함
 *                                                    예) "전자정부프레임워크", 애니프레임워크
 *                                                    
 *      ----------------------------------------------------------------------
 *      
 *      객체지향의 3대 특성 ==> 문법사항아님 권장사항임 ==> 객체지향에 연연하지 말고...
 *      --------------
 *         ⓐ 상속 : 변경사항이 있는 경우
 *         class Window extends JFrame //=재사용
 *         ⓑ 포함 : 변경사항이 없는 경우
 *         class Window
 *         {
 *            JFrame f=new JFrame(); //=재사용
 *         }
 *         ==> 웹/스프링 => 상속이 거의 없다 => 포함을 주로 사용~~
 *      
 *      1. 캡슐화 => 데이터 보호
 *              : 멤버변수 => private(은닉화) => 기능(=메소드) 설정을 통해 접근
 *                                           -------------
 *                                           멤버변수 저장/읽기를 위해 getter/setter를 사용
 *              : 데이터를 감추고 메소드(getter/setter)를 통해서 접근하는 방식
 *              
 *      2. 상속/포함 => 기존의 클래스를 재사용
 *         2-1.[상속] 
 *              목적) 
 *                 = 재사용(신뢰성 상승, 개발속도 증가로 이어짐)
 *                 = "유지보수"를 쉽게 만든다
 *                 = 중복을 최대한 제거
 *                 = 통일성 있는 코드 작성
 *              단점) 실행속도가 늦다 (게임게발은 java로 불가능 요즘은 어셈블러로 개발한다네용...)
 *              장점) 적은양의 코드로 새로운 클래스 작성 가능
 *                   예)class A extends JFrame으로 JFrame의 방대한 양 상속가능
 *              특징) 코드를 공통적으로 관리하기 때문에 여러코드를 추가 , 변경이 용이
 *                                           ----------   --------
 *                                             오버로딩      오버라이딩
 *                   ① 생성자, 초기화블록 은 상속이 되지 않는다
 *                   ② 상속받은 클래스의 객체 생성시 => 상속내림클래스(상위클래스) 먼저 메모리 할당을 한다
 *                     예)
 *                     class A
 *                     {
 *                        int a,b;
 *                        String s;
 *                        
 *                        //생성자 없으니까 default 생성자 자동생성됨
 *                        public A()
 *                        {
 *                        }
 *                     }
 *                     class B extends A
 *                     {
 *                        int c,d;
 *                        
 *                        
 *                        //생성자 없으니까 default 생성자 자동생성됨
 *                        public B()
 *                        {
 *                           super(); //상위클래스 먼저 메모리 할당 해야하니까 항상 super가 생략되어있음
 *                        }
 *                        
 *                     }
 *                     B b=new B();
 *                     [stack]=> 메모리에서처리(할당,해제)
 *                     ---b---
 *                     -------        [Heap]=> 실제 데이터 저장(프로그래머영역)
 *                               -----------------
 *                                -----super----
 *                                 ------a------
 *                                 ------b------
 *                                 ------s------
 *                               -----------------
 *                                ------sub------
 *                                 ------s------
 *                                 ------d------
 *                               -----------------
 *                   ③ 모든 클래스의 상위 클래스는 (최상위클래스) => Object
 *                      private 상속은 된다 접근이 불가능
 *                      protected 상속도 되고 접근도 가능
 *                 
 *                   ④ 상속 => 상위클래스 => super
 *                          => 자신클래스 => this
 *                   ⑤ 상속 내리는 클래스 : 상속 받은 클래스에 접근이 불가능(본인클래스에만 접근가능)
 *                     상속 받 는 클래스 : 자신+상속 내리는 클래스까지 접근이 가능
 *                                   this+super
 *                   
 *              작성방법) 
 *                 => 확장한다 => 기존의 클래스를 확장해서 새로운 클래스 제작
 *                   extends
 *                   -------
 *                   예) class Parent
 *                      class Child extends Parent
 *                   단점) 단일상속만 가능하다
 *              
 *         2-1.[포함] 
 *              목적) 
 *              
 *                   
 *      3. 다형성 => 필요시에!
 *                      => 변경해서 사용 = 오버라이딩
 *                      => 추가해서 사용 = 오버로딩
 *      
 */
class A
{
	int a;
	
	//--해당부분은 생략되어있음 존재는함--
	public A() {
		super();//A에서 상위는 Object
		//this.를 이용해서 Object의 변수를 사용할수도 있음!!
	}
	//-------------------------
	
}
class B extends A
{
	int c;
	//--해당부분은 생략되어있음 존재는함--
		public B() {
			super();//B에서 상위는 A
		}
    //-------------------------
}
public class MainClass {
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
