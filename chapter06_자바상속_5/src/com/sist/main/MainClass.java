package com.sist.main;
/*
 *      ==> 웹/스프링 => 상속이 거의 없다 => 포함을 주로 사용~~
 *      
 *      => 추후에는 실행속도를 높일수 있도록 최적화작업을 해줘야함
 *      => exe => 자바는 웹J2EE과 모바일J2ME에 강함 => J2SE
 *      
 *      *** 자바는 오버라이딩이다 => 기존 내용도 변경할 부분이 많기때문
 *                                     ---을 쉽게하기 위해 프레임워크(실제소스)를 주로 사용함
 *                                                    예) "전자정부프레임워크", 애니프레임워크
 *                                                    
 *      *** 객체프로그램의 객체란 현실세계를 특성화 하는것이며 특성화는 추상화 단순화로 이어진다
 *          혹은? 
 *          "내가 써봤을때" 객체는 메모리 주소를 뜻하는거 같다 처럼 "경험을 토대로 이론질문을 답하는 스킬"도 있어야한다
 *                                                    
 *      ----------------------------------------------------------------------
 *      
 *      객체지향의 3대 특성 ==> 문법사항아님 권장사항임 ==> 객체지향에 연연하지 말고...
 *      --------------
 *      1. 캡슐화 => 데이터 보호
 *              : 멤버변수 => private(은닉화) => 기능(=메소드) 설정을 통해 접근
 *                                           -------------
 *                                           멤버변수 저장/읽기를 위해 getter/setter를 사용
 *              : 데이터를 감추고 메소드(getter/setter)를 통해서 접근하는 방식
 *              
 *      2. 상속/포함 => 기존의 클래스를 재사용 
 *                => 클래스를 비교할 수 있다. 
 *         2-1.[상속 is-a] : 변경사항이 있는 경우 : (override)를 사용해서 사용
 *                     class Window extends JFrame //=재사용
 *              목적) 
 *                 = 재사용(신뢰성 상승, 개발속도 증가로 이어짐)
 *                 = "유지보수"를 쉽게 만든다
 *                 = 중복을 최대한 제거
 *                 = 통일성 있는 코드 작성
 *              단점) 실행속도가 늦다 (게임게발은 java로 불가능 요즘은 어셈블러로 개발한다네용...)
 *              장점) 적은양의 코드로 새로운 클래스 작성 가능
 *                   예)class A extends JFrame으로 JFrame의 방대한 양 상속가능
 *              특징) 코드를 공통적으로 관리하기 때문에 여러코드를 추가 , 변경이 용이
 *                                           ----------   --------
 *                                             오버로딩      오버라이딩
 *                   ① 생성자, 초기화블록 은 상속이 되지 않는다
 *                   ② 상속받은 클래스의 객체 생성시 => 상속내림클래스(상위클래스) 먼저 메모리 할당을 한다
 *                     예)
 *                     class A
 *                     {
 *                        int a,b;
 *                        String s;
 *                        
 *                        //생성자 없으니까 default 생성자 자동생성됨
 *                        public A()
 *                        {
 *                        }
 *                     }
 *                     class B extends A
 *                     {
 *                        int c,d;
 *                        
 *                        
 *                        //생성자 없으니까 default 생성자 자동생성됨
 *                        public B()
 *                        {
 *                           super(); //상위클래스 먼저 메모리 할당 해야하니까 항상 super가 생략되어있음
 *                        }
 *                        
 *                     }
 *                     B b=new B();
 *                     [stack]=> 메모리에서처리(할당,해제)
 *                     ---b---
 *                     -------        [Heap]=> 실제 데이터 저장(프로그래머영역)
 *                               -----------------
 *                                -----super----
 *                                 ------a------
 *                                 ------b------
 *                                 ------s------
 *                               -----------------
 *                                ------sub------
 *                                 ------s------
 *                                 ------d------
 *                               -----------------
 *                   ③ 모든 클래스의 상위 클래스는 (최상위클래스) => Object
 *                      private 상속은 된다 접근이 불가능
 *                      protected 상속도 되고 접근도 가능
 *                 
 *                   ④ 상속 => 상위클래스 => super
 *                          => 자신클래스 => this
 *                   ⑤ 상속 내리는 클래스 : 상속 받은 클래스에 접근이 불가능(본인클래스에만 접근가능)
 *                     상속 받 는 클래스 : 자신+상속 내리는 클래스까지 접근이 가능
 *                                   this+super
 *                   
 *              작성방법) 
 *                 => 확장한다 => 기존의 클래스를 확장해서 새로운 클래스 제작
 *                   extends
 *                   -------
 *                   예) class Parent
 *                      class Child extends Parent
 *                   단점) 단일상속만 가능하다
 *              
 *              예외조건) static : 공통으로 사용이 가능
 *                     생성자/초기화블록 : 상속안됨
 *                     private : 상속은 되나 접근이 안됨
 *              
 *              주의점1) 접근지정어의 위치를 잘 기억하기
 *                     클래스 => [접근지정어] class 클래스명
 *                          : 기본은 public을 사용 => 다른 메모리 할당
 *                         
 *                     메소드 => [접근지정어] 리턴형 메소드명 (매개변수)
 *                          : 기본은 public을 사용 
 *                         
 *                     멤벼변수 => [접근지정어] 데이터형 변수명
 *                           : 기본은 private를 쓰되 protected도 사용
 *                          
 *                     생성자 => [접근지정어] 클래스명()
 *                          : 기본 public을 사용
 *                         
 *                     지역/매개변수 => 유일하게 final(상수형)만 사용가능
 *                               : 접근지정어 , static을 사용할수 없다
 *              주의점2) ~메소드~
 *                     = 멤버메소드 : static변수/메소드나 멤버변수/메소드를 사용할 수 있다.
 *                     = static메소드 : static만 자유롭게 사용이 가능
 *                                  => 만약 멤벼변수/메소드를 사용할 때는 "반드시 객체생성 후 사용"
 *                                                               ----------------
 *                                                               예)
 *                                                                 class A
 *                                                                 {
 *                                                                    [사진으로찍어둠~~~~]
 *                                                                 }
 *                    ~초기화블록~ : 자동호출
 *                    = 인스턴스블록
 *                      {
 *                         static,멤버변수를 초기화
 *                      }
 *                    = static 블록
 *                      static{
 *                         static변수만 초기화
 *                      }
 *                      
 *                    **변수에 대한 초기화
 *                      1) 명시적초기화
 *                      2) 초기화 블록 : static변수 초기화로 많이쓰임(static은 메모리자동할당이니까)
 *                      3) 생성자 : 인스턴스변수 초기화로 많이쓰임(new로 메모리 할당을 해야하니까)
 *                              : 혹은 시작돠 동시에 처리해야할 일이 있을때 주로사용(예시로는 쿠키나..화면구현이나..등등)
 *                              : 일반에서는 데이터베이스 연결이나 서버연결에서 주로 쓰임
 *                      => 클래스영역은 선언만 가능함으로
 *                         구현부분의 경우는 2.3에서 실행을 해줘야함
 *                                                            
 *              
 *         2-1.[포함 has-a] : 변경사항이 없는 경우 : 그대로 사용할때
 *                           class Window
 *                           {
 *                              JFrame f=new JFrame(); //=재사용
 *                           }
 *              목적) 
 *              
 *                   
 *      3. 다형성 => 필요시에!
 *                      => 변경해서 사용 = 오버라이딩
 *                      => 추가해서 사용 = 오버로딩
 *          *
 *          [접근지정어] 리턴형 메소드 (매개변수) 4가지 구성에서 
 *          오버로딩과 오버라이딩의 역할
 *         --------------------------------------
 *                     오버라이딩          오버로딩    ====> 의 차이점은 기술면접에 100%나옴
 *         --------------------------------------
 *                  Modify            New
 *                  기존의기능을변경       새로운기능추가
 *         --------------------------------------
 *          상태          상속              같은
 *                   =>그러나 상속         클래스에서
 *                   없이도 (익명의클래스)     작업을
 *                   는 오버라이딩가능        해야함
 *         --------------------------------------
 *          메소드명          이름이 동일해야함
 *         --------------------------------------
 *          매개변수       이름이        갯수나 데이터형이 
 *                     동일해야함          달라야함
 *         --------------------------------------
 *          리턴형       동일해아함          관계없음
 *         --------------------------------------
 *          접근지정어    축소는 불가능        관계없음
 *                     확대는 가능
 *         --------------------------------------
 *                  => 접근지정어 크기비교
 *                     기억하면됨 그러나 
 *                     메소드는 보통 
 *                     public을 사용함~~
 *                  
 *      
 */
class A
{
	int a;
	
	//--해당부분은 생략되어있음 존재는함--
	public A() {
		super();//A에서 상위는 Object
		//this.를 이용해서 Object의 변수를 사용할수도 있음!!
	}
	//-------------------------
	
}
class B extends A
{
	int c;
	//--해당부분은 생략되어있음 존재는함--
		public B() {
			super();//B에서 상위는 A
		}
    //-------------------------
}
public class MainClass {
	

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
